/*
 * generated by Xtext 2.38.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ArrayValue;
import org.xtext.example.mydsl.myDsl.Field;
import org.xtext.example.mydsl.myDsl.FieldType;
import org.xtext.example.mydsl.myDsl.FieldValue;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NumberLiteral;
import org.xtext.example.mydsl.myDsl.PrimitiveType;
import org.xtext.example.mydsl.myDsl.RefType;
import org.xtext.example.mydsl.myDsl.StringLiteral;
import org.xtext.example.mydsl.myDsl.StructValue;
import org.xtext.example.mydsl.myDsl.TypeDef;
import org.xtext.example.mydsl.myDsl.UnionType;
import org.xtext.example.mydsl.myDsl.VarDef;
import org.xtext.example.mydsl.myDsl.VarRef;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ARRAY_VALUE:
				sequence_ArrayValue(context, (ArrayValue) semanticObject); 
				return; 
			case MyDslPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MyDslPackage.FIELD_TYPE:
				sequence_FieldType(context, (FieldType) semanticObject); 
				return; 
			case MyDslPackage.FIELD_VALUE:
				sequence_FieldValue(context, (FieldValue) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case MyDslPackage.PRIMITIVE_TYPE:
				sequence_PrimitiveType(context, (PrimitiveType) semanticObject); 
				return; 
			case MyDslPackage.REF_TYPE:
				sequence_RefType(context, (RefType) semanticObject); 
				return; 
			case MyDslPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MyDslPackage.STRUCT_VALUE:
				sequence_StructValue(context, (StructValue) semanticObject); 
				return; 
			case MyDslPackage.TYPE_DEF:
				sequence_TypeDef(context, (TypeDef) semanticObject); 
				return; 
			case MyDslPackage.UNION_TYPE:
				sequence_UnionType(context, (UnionType) semanticObject); 
				return; 
			case MyDslPackage.VAR_DEF:
				sequence_VarDef(context, (VarDef) semanticObject); 
				return; 
			case MyDslPackage.VAR_REF:
				sequence_VarRef(context, (VarRef) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns ArrayValue
	 *     ArrayValue returns ArrayValue
	 *
	 * Constraint:
	 *     (elements+=Value elements+=Value*)
	 * </pre>
	 */
	protected void sequence_ArrayValue(ISerializationContext context, ArrayValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldType returns FieldType
	 *
	 * Constraint:
	 *     (union=UnionType array?='[]'?)
	 * </pre>
	 */
	protected void sequence_FieldType(ISerializationContext context, FieldType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FieldValue returns FieldValue
	 *
	 * Constraint:
	 *     (name=ID value=Value)
	 * </pre>
	 */
	protected void sequence_FieldValue(ISerializationContext context, FieldValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIELD_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIELD_VALUE__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIELD_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIELD_VALUE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldValueAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldValueAccess().getValueValueParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID type=FieldType)
	 * </pre>
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FIELD__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FIELD__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getTypeFieldTypeParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID types+=TypeDef* vars+=VarDef*)
	 * </pre>
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns NumberLiteral
	 *     Literal returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns PrimitiveType
	 *     PrimitiveType returns PrimitiveType
	 *
	 * Constraint:
	 *     (value='string' | value='number')
	 * </pre>
	 */
	protected void sequence_PrimitiveType(ISerializationContext context, PrimitiveType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     SimpleType returns RefType
	 *     RefType returns RefType
	 *
	 * Constraint:
	 *     type=[TypeDef|ID]
	 * </pre>
	 */
	protected void sequence_RefType(ISerializationContext context, RefType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.REF_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.REF_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRefTypeAccess().getTypeTypeDefIDTerminalRuleCall_0_1(), semanticObject.eGet(MyDslPackage.Literals.REF_TYPE__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     StructValue returns StructValue
	 *     Value returns StructValue
	 *
	 * Constraint:
	 *     (entries+=FieldValue entries+=FieldValue*)
	 * </pre>
	 */
	protected void sequence_StructValue(ISerializationContext context, StructValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TypeDef returns TypeDef
	 *
	 * Constraint:
	 *     (name=ID (fields+=Field fields+=Field*)?)
	 * </pre>
	 */
	protected void sequence_TypeDef(ISerializationContext context, TypeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UnionType returns UnionType
	 *
	 * Constraint:
	 *     (types+=SimpleType types+=SimpleType*)
	 * </pre>
	 */
	protected void sequence_UnionType(ISerializationContext context, UnionType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     VarDef returns VarDef
	 *
	 * Constraint:
	 *     (name=ID type=[TypeDef|ID] value=StructValue)
	 * </pre>
	 */
	protected void sequence_VarDef(ISerializationContext context, VarDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VAR_DEF__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VAR_DEF__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VAR_DEF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VAR_DEF__TYPE));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VAR_DEF__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VAR_DEF__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarDefAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVarDefAccess().getTypeTypeDefIDTerminalRuleCall_3_0_1(), semanticObject.eGet(MyDslPackage.Literals.VAR_DEF__TYPE, false));
		feeder.accept(grammarAccess.getVarDefAccess().getValueStructValueParserRuleCall_5_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Value returns VarRef
	 *     VarRef returns VarRef
	 *
	 * Constraint:
	 *     ref=[VarDef|ID]
	 * </pre>
	 */
	protected void sequence_VarRef(ISerializationContext context, VarRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VAR_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VAR_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarRefAccess().getRefVarDefIDTerminalRuleCall_0_1(), semanticObject.eGet(MyDslPackage.Literals.VAR_REF__REF, false));
		feeder.finish();
	}
	
	
}
