/**
 * generated by Xtext 2.38.0
 */
package org.xtext.example.mydsl.generator;

import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.xtext.example.mydsl.myDsl.ArrayValue;
import org.xtext.example.mydsl.myDsl.Field;
import org.xtext.example.mydsl.myDsl.FieldType;
import org.xtext.example.mydsl.myDsl.FieldValue;
import org.xtext.example.mydsl.myDsl.Literal;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.NumberLiteral;
import org.xtext.example.mydsl.myDsl.PrimitiveType;
import org.xtext.example.mydsl.myDsl.RefType;
import org.xtext.example.mydsl.myDsl.SimpleType;
import org.xtext.example.mydsl.myDsl.StringLiteral;
import org.xtext.example.mydsl.myDsl.StructValue;
import org.xtext.example.mydsl.myDsl.TypeDef;
import org.xtext.example.mydsl.myDsl.Value;
import org.xtext.example.mydsl.myDsl.VarDef;
import org.xtext.example.mydsl.myDsl.VarRef;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MyDslGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    EObject _head = IterableExtensions.<EObject>head(resource.getContents());
    final Model model = ((Model) _head);
    final String systemName = model.getName();
    final String basePath = (systemName + "/");
    EList<TypeDef> _types = model.getTypes();
    for (final TypeDef type : _types) {
      {
        String _name = type.getName();
        String _plus = (basePath + _name);
        final String typeFile = (_plus + ".ts");
        fsa.generateFile(typeFile, this.generateTypeScript(type));
      }
    }
    final String mainFile = (basePath + "main.ts");
    fsa.generateFile(mainFile, this.generateMainTs(model));
  }

  /**
   * Generates a TypeScript type definition from a TypeDef.
   * Example output:
   * export type MyType = {
   *   field1: string;
   *   field2: number[];
   * }
   */
  public CharSequence generateTypeScript(final TypeDef type) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("export type ");
    String _name = type.getName();
    _builder.append(_name);
    _builder.append(" = {");
    _builder.newLineIfNotEmpty();
    {
      EList<Field> _fields = type.getFields();
      for(final Field field : _fields) {
        String _name_1 = field.getName();
        _builder.append(_name_1);
        _builder.append(": ");
        String _typeScriptType = this.toTypeScriptType(field.getType());
        _builder.append(_typeScriptType);
        _builder.newLineIfNotEmpty();
      }
    }
    _builder.append("}");
    _builder.newLine();
    return _builder;
  }

  /**
   * Converts a FieldType from the DSL to a valid TypeScript type.
   * Supports unions and array types.
   * Example: string | number[]
   */
  public String toTypeScriptType(final FieldType ft) {
    String _xblockexpression = null;
    {
      final EList<SimpleType> types = ft.getUnion().getTypes();
      final Function1<SimpleType, String> _function = (SimpleType st) -> {
        String _switchResult = null;
        boolean _matched = false;
        if (st instanceof PrimitiveType) {
          _matched=true;
          _switchResult = ((PrimitiveType) st).getValue();
        }
        if (!_matched) {
          if (st instanceof RefType) {
            _matched=true;
            _switchResult = ((RefType) st).getType().getName();
          }
        }
        if (!_matched) {
          _switchResult = "/*error:Unknown_SimpleType_subtype*/any";
        }
        return _switchResult;
      };
      final String baseType = IterableExtensions.join(ListExtensions.<SimpleType, String>map(types, _function), " | ");
      String _xifexpression = null;
      boolean _isArray = ft.isArray();
      if (_isArray) {
        _xifexpression = (baseType + "[]");
      } else {
        _xifexpression = baseType;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }

  /**
   * Generates the contents of main.ts:
   * - Imports all used types
   * - Declares all variables
   * - Logs all variables
   */
  public CharSequence generateMainTs(final Model model) {
    CharSequence _xblockexpression = null;
    {
      final LinkedHashSet<String> typeImports = new LinkedHashSet<String>();
      final Function1<VarDef, CharSequence> _function = (VarDef it) -> {
        return this.generateVariableDeclaration(it, typeImports);
      };
      final List<CharSequence> variables = ListExtensions.<VarDef, CharSequence>map(model.getVars(), _function);
      final Function1<VarDef, String> _function_1 = (VarDef it) -> {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("console.log(");
        String _name = it.getName();
        _builder.append(_name);
        _builder.append(");");
        return _builder.toString();
      };
      final List<String> logs = ListExtensions.<VarDef, String>map(model.getVars(), _function_1);
      StringConcatenation _builder = new StringConcatenation();
      {
        for(final String t : typeImports) {
          _builder.append("import { ");
          _builder.append(t);
          _builder.append(" } from \"./");
          _builder.append(t);
          _builder.append("\";");
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.newLine();
      {
        for(final CharSequence v : variables) {
          _builder.append(v);
          _builder.newLineIfNotEmpty();
        }
      }
      _builder.newLine();
      {
        for(final String l : logs) {
          _builder.append(l);
          _builder.newLineIfNotEmpty();
        }
      }
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }

  /**
   * Generates a TypeScript variable declaration line.
   * Example: export const myVar: MyType = { ... };
   */
  public CharSequence generateVariableDeclaration(final VarDef v, final Set<String> imports) {
    CharSequence _xblockexpression = null;
    {
      imports.add(v.getType().getName());
      final CharSequence valueStr = this.toJsonString(v.getValue());
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("export const ");
      String _name = v.getName();
      _builder.append(_name);
      _builder.append(": ");
      String _name_1 = v.getType().getName();
      _builder.append(_name_1);
      _builder.append(" = ");
      _builder.append(valueStr);
      _builder.append(";");
      _xblockexpression = _builder;
    }
    return _xblockexpression;
  }

  /**
   * Recursively converts a DSL Value to a TypeScript/JSON-compatible string.
   * Supports:
   * - String and number literals
   * - Struct (object) values
   * - Var references
   * - Arrays of values
   */
  public CharSequence toJsonString(final Value value) {
    CharSequence _switchResult = null;
    boolean _matched = false;
    if (value instanceof Literal) {
      _matched=true;
      CharSequence _switchResult_1 = null;
      boolean _matched_1 = false;
      if (value instanceof StringLiteral) {
        _matched_1=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("\"");
        String _value = ((StringLiteral)value).getValue();
        _builder.append(_value);
        _builder.append("\"");
        _switchResult_1 = _builder;
      }
      if (!_matched_1) {
        if (value instanceof NumberLiteral) {
          _matched_1=true;
          StringConcatenation _builder = new StringConcatenation();
          int _value = ((NumberLiteral)value).getValue();
          _builder.append(_value);
          _switchResult_1 = _builder;
        }
      }
      if (!_matched_1) {
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("null");
        _switchResult_1 = _builder;
      }
      _switchResult = _switchResult_1;
    }
    if (!_matched) {
      if (value instanceof StructValue) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("{");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        {
          EList<FieldValue> _entries = ((StructValue)value).getEntries();
          boolean _hasElements = false;
          for(final FieldValue e : _entries) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(", ", "\t\t\t\t");
            }
            String _name = e.getName();
            _builder.append(_name, "\t\t\t\t");
            _builder.append(": ");
            CharSequence _jsonString = this.toJsonString(e.getValue());
            _builder.append(_jsonString, "\t\t\t\t");
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t\t");
        _builder.append("}");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (value instanceof VarRef) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        String _name = ((VarRef)value).getRef().getName();
        _builder.append(_name);
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      if (value instanceof ArrayValue) {
        _matched=true;
        StringConcatenation _builder = new StringConcatenation();
        _builder.append("[");
        _builder.newLine();
        _builder.append("\t\t\t\t");
        {
          EList<Value> _elements = ((ArrayValue)value).getElements();
          boolean _hasElements = false;
          for(final Value e : _elements) {
            if (!_hasElements) {
              _hasElements = true;
            } else {
              _builder.appendImmediate(", ", "\t\t\t\t");
            }
            CharSequence _jsonString = this.toJsonString(e);
            _builder.append(_jsonString, "\t\t\t\t");
          }
        }
        _builder.newLineIfNotEmpty();
        _builder.append("\t\t\t");
        _builder.append("]");
        _switchResult = _builder;
      }
    }
    if (!_matched) {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("null");
      _switchResult = _builder;
    }
    return _switchResult;
  }
}
