/*
  * generated by Xtext 2.38.0
  */
 package org.xtext.example.mydsl.generator
 
 import org.eclipse.emf.ecore.resource.Resource;
 import org.eclipse.xtext.generator.AbstractGenerator;
 import org.eclipse.xtext.generator.IFileSystemAccess2;
 import org.eclipse.xtext.generator.IGeneratorContext;
 import org.eclipse.emf.common.util.EList
 import org.eclipse.emf.ecore.EObject
 import org.xtext.example.mydsl.myDsl.Model;
 import java.util.List
 import java.util.ArrayList
import org.xtext.example.mydsl.myDsl.TypeDef
import org.xtext.example.mydsl.myDsl.FieldType
import java.util.LinkedHashSet
import org.xtext.example.mydsl.myDsl.VarDef
import java.util.Set
import org.xtext.example.mydsl.myDsl.NumberLiteral 
import org.xtext.example.mydsl.myDsl.StringLiteral
import org.xtext.example.mydsl.myDsl.StructValue
import org.xtext.example.mydsl.myDsl.VarRef
import org.xtext.example.mydsl.myDsl.ArrayValue
import org.xtext.example.mydsl.myDsl.Value
import org.xtext.example.mydsl.myDsl.Literal
import org.xtext.example.mydsl.myDsl.SimpleType;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.xtext.example.mydsl.myDsl.RefType
import org.xtext.example.mydsl.myDsl.PrimitiveType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as Model
		val systemName = model.name
		val basePath = systemName + "/"
		// Generate a separate .ts file for each type definition
		for (type : model.types) {
			val typeFile = basePath + type.name + ".ts"
			fsa.generateFile(typeFile, generateTypeScript(type))
		}
		// Generate a main.ts file that contains variable declarations and console logs
		val mainFile = basePath + "main.ts"
		fsa.generateFile(mainFile, generateMainTs(model))
		
	}
	/**
	 * Generates a TypeScript type definition from a TypeDef.
	 * Example output:
	 * export type MyType = {
	 *   field1: string;
	 *   field2: number[];
	 * }
	 */
	def CharSequence generateTypeScript(TypeDef type) '''
		export type «type.name» = {
		«FOR field : type.fields»
			«field.name»: «field.type.toTypeScriptType()»
		«ENDFOR»
		}
	'''
	/**
	 * Converts a FieldType from the DSL to a valid TypeScript type.
	 * Supports unions and array types.
	 * Example: string | number[]
	 */
	def String toTypeScriptType(FieldType ft) {
        val types = ft.union.types
        val baseType = types.map [ st |
          
            switch st {
                PrimitiveType:
                    (st as PrimitiveType).value // e.g "string or "number"
                RefType:
                    (st as RefType).type.name // reference to a custom type
                default:
                    "/*error:Unknown_SimpleType_subtype*/any"
            }
        ].join(" | ") // Join multiple types using TypeScript's union syntax

        if (ft.array) baseType + "[]" else baseType
    }
    
	/**
	 * Generates the contents of main.ts:
	 * - Imports all used types
	 * - Declares all variables
	 * - Logs all variables
	 */
	def CharSequence generateMainTs(Model model) {
		val typeImports = new LinkedHashSet<String>()
		val variables = model.vars.map [ generateVariableDeclaration(it, typeImports) ] // Generate var declarations
		val logs = model.vars.map [ '''console.log(«name»);''' ] // Generate simple console logs

		'''
		«FOR t : typeImports»
		import { «t» } from "./«t»";
		«ENDFOR»

		«FOR v : variables»
		«v»
		«ENDFOR»

		«FOR l : logs»
		«l»
		«ENDFOR»
		'''
	}
	
	/**
	 * Generates a TypeScript variable declaration line.
	 * Example: export const myVar: MyType = { ... };
	 */
	def CharSequence generateVariableDeclaration(VarDef v, Set<String> imports) {
		imports.add(v.type.name)
		val valueStr = v.value.toJsonString
		'''export const «v.name»: «v.type.name» = «valueStr»;'''
	}
	
	/**
	 * Recursively converts a DSL Value to a TypeScript/JSON-compatible string.
	 * Supports:
	 * - String and number literals
	 * - Struct (object) values
	 * - Var references
	 * - Arrays of values
	 */
	def CharSequence toJsonString(Value value) {
		switch value {
			Literal: switch value {
				StringLiteral: '''"«value.value»"'''
				NumberLiteral: '''«value.value»'''
				default: '''null'''
			}
			StructValue: '''{
				«FOR e : value.entries SEPARATOR ", "»«e.name»: «e.value.toJsonString»«ENDFOR»
			}'''
			VarRef: '''«value.ref.name»'''
			ArrayValue: '''[
				«FOR e : value.elements SEPARATOR ", "»«e.toJsonString»«ENDFOR»
			]'''
			default: '''null'''
		}
	}
	
}