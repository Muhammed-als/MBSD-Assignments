/*
  * generated by Xtext 2.38.0
  */
 package org.xtext.example.mydsl.generator
 
 import org.eclipse.emf.ecore.resource.Resource;
 import org.eclipse.xtext.generator.AbstractGenerator;
 import org.eclipse.xtext.generator.IFileSystemAccess2;
 import org.eclipse.xtext.generator.IGeneratorContext;
 import org.eclipse.emf.common.util.EList
 import org.eclipse.emf.ecore.EObject
 import org.xtext.example.mydsl.myDsl.Model;
 import java.util.List
 import java.util.ArrayList
import org.xtext.example.mydsl.myDsl.TypeDef
import org.xtext.example.mydsl.myDsl.FieldType
import java.util.LinkedHashSet
import org.xtext.example.mydsl.myDsl.VarDef
import java.util.Set
import org.xtext.example.mydsl.myDsl.NumberLiteral 
import org.xtext.example.mydsl.myDsl.StringLiteral
import org.xtext.example.mydsl.myDsl.StructValue
import org.xtext.example.mydsl.myDsl.VarRef
import org.xtext.example.mydsl.myDsl.ArrayValue
import org.xtext.example.mydsl.myDsl.Value
import org.xtext.example.mydsl.myDsl.Literal
import org.xtext.example.mydsl.myDsl.SimpleType;
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.xtext.example.mydsl.myDsl.RefType
import org.xtext.example.mydsl.myDsl.PrimitiveType

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as Model
		val systemName = model.name
		val basePath = systemName + "/"
		// Generate type files
		for (type : model.types) {
			val typeFile = basePath + type.name + ".ts"
			fsa.generateFile(typeFile, generateTypeScript(type))
		}
		
		// Generate a single main.ts file
		val mainFile = basePath + "main.ts"
		fsa.generateFile(mainFile, generateMainTs(model))
		
	}
	
	def CharSequence generateTypeScript(TypeDef type) '''
		export type «type.name» = {
		«FOR field : type.fields»
			«field.name»: «field.type.toTypeScriptType()»
		«ENDFOR»
		}
	'''
	
	def String toTypeScriptType(FieldType ft) {
        val types = ft.union.types // This is an EList<SimpleType>
        val baseType = types.map [ st | // st is an instance of SimpleType (which will be PrimitiveType or RefType)
            // Use a switch statement to dispatch based on the actual concrete type of st
            switch st {
                // Case for when st is an instance of your DSL's PrimitiveType
                PrimitiveType:
                    // Cast 'st' to PrimitiveType to access its 'value' feature
                    (st as PrimitiveType).value
                // Case for when st is an instance of your DSL's RefType
                RefType:
                    // Cast 'st' to RefType to access its 'type' feature
                    (st as RefType).type.name
                default:
                    // This should ideally not be reached if the model is valid
                    // and st is always either a PrimitiveType or a RefType.
                    "/*error:Unknown_SimpleType_subtype*/any"
            }
        ].join(" | ")

        if (ft.array) baseType + "[]" else baseType
    }
	
	def CharSequence generateMainTs(Model model) {
		val typeImports = new LinkedHashSet<String>()
		val variables = model.vars.map [ generateVariableDeclaration(it, typeImports) ]
		val logs = model.vars.map [ '''console.log(«name»);''' ]

		'''
		«FOR t : typeImports»
		import { «t» } from "./«t»";
		«ENDFOR»

		«FOR v : variables»
		«v»
		«ENDFOR»

		«FOR l : logs»
		«l»
		«ENDFOR»
		'''
	}
	
	def CharSequence generateVariableDeclaration(VarDef v, Set<String> imports) {
		imports.add(v.type.name)
		val valueStr = v.value.toJsonString
		'''export const «v.name»: «v.type.name» = «valueStr»;'''
	}
	
	def CharSequence toJsonString(Value value) {
		switch value {
			Literal: switch value {
				StringLiteral: '''"«value.value»"'''
				NumberLiteral: '''«value.value»'''
				default: '''null'''
			}
			StructValue: '''{
				«FOR e : value.entries SEPARATOR ", "»«e.name»: «e.value.toJsonString»«ENDFOR»
			}'''
			VarRef: '''«value.ref.name»'''
			ArrayValue: '''[
				«FOR e : value.elements SEPARATOR ", "»«e.toJsonString»«ENDFOR»
			]'''
			default: '''null'''
		}
	}
	
}