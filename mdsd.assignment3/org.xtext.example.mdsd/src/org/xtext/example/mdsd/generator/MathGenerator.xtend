/*
 * generated by Xtext 2.38.0
 */
package org.xtext.example.mdsd.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mdsd.math.MathExp
import java.util.HashMap
import javax.swing.JOptionPane
import org.xtext.example.mdsd.math.VarBinding
import org.xtext.example.mdsd.math.MathNumber
import org.xtext.example.mdsd.math.Plus
import org.xtext.example.mdsd.math.Minus
import org.xtext.example.mdsd.math.Mult
import org.xtext.example.mdsd.math.Div
import org.xtext.example.mdsd.math.LetBinding
import java.util.Map
import org.xtext.example.mdsd.math.VariableUse
import org.xtext.example.mdsd.math.ExternalDecl

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, Integer> variables;

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val math = resource.allContents.filter(MathExp).next
		val className = math.name
		val content = generateJavaClass(math)
		fsa.generateFile("math_expression/" + className + ".java", content)
		
	}
	def CharSequence generateJavaClass(MathExp math) '''
		package math_expression;
		
		public class «math.name» {
			
			«IF !math.externals.empty»
			private External external;
			
			public «math.name»(External external) {
				this.external = external;
			}
			«ENDIF»
		
			«FOR varriable : math.variables»
			public int «varriable.name»;
			«ENDFOR»
		
			public void compute() {
				«FOR varriable : math.variables»
				«varriable.name» = «generateExpression(varriable.expression)»;
				«ENDFOR»
			}
		
			«IF !math.externals.empty»
			public interface External {
				«FOR ext : math.externals»
				int «ext.name»(«FOR i : 0 ..< ext.parameters.size SEPARATOR ', '»int arg«i»«ENDFOR»);
				«ENDFOR»
			}
			«ENDIF»
		}
		'''
		
	def dispatch CharSequence generateExpression(MathNumber num) '''«num.value»'''
	def dispatch CharSequence generateExpression(Plus exp) '''«generateExpression(exp.left)» + «generateExpression(exp.right)»'''
	def dispatch CharSequence generateExpression(Minus exp) '''«generateExpression(exp.left)» - «generateExpression(exp.right)»'''
	def dispatch CharSequence generateExpression(Mult exp) '''«generateExpression(exp.left)» * «generateExpression(exp.right)»'''
	def dispatch CharSequence generateExpression(Div exp) '''«generateExpression(exp.left)» / «generateExpression(exp.right)»'''
	def dispatch CharSequence generateExpression(VariableUse use) '''«use.ref.name»'''
	def dispatch CharSequence generateExpression(LetBinding let) '''
		new Object() {
			int result() {
				final int __shadow = «generateExpression(let.binding)»;
				int «let.name» = __shadow;
				return «generateExpression(let.body)»;
			}
		}.result()
		'''
	def dispatch CharSequence generateExpression(org.xtext.example.mdsd.math.FunctionCall call) '''
		external.«call.name.name»(«FOR arg : call.arguments SEPARATOR ", "»«generateExpression(arg)»«ENDFOR»)
		'''
	def getNameParameters(ExternalDecl ext) {
    	return ext.parameters
	}
}
